\documentclass[]{article}

\usepackage{listings}

%opening
\title{CSE150 -- Project 3\\ Networks and Distributed Systems}
\author{Group Thimbles}

\begin{document}

\maketitle

\section{Socket object}
\paragraph{Overview}
The socket object keeps track of the state of the network sockets on both the client and server side. It also maintains the TCP state machine and the mapped ports, as well as the associated \texttt{FileObject} file descriptor.

\paragraph{TCP state machine}

The socket object contains a TCP state machine implementing the seven TCP states and the transitions between them, which occur based on syscalls, timer events or the receipt of TCP-flagged packets, such as \texttt{ACK} or \texttt{STP}.

\paragraph{Port mapping}
Ports are mapped to sockets for both incoming and outgoing connections.

\section{Networking syscalls}
\subsection{connect()}

\paragraph{Overview}
The \texttt{connect()} syscall takes as arguments the host address and the port to which a connection will be opened. It begins by disabling interrupts and creating a new socket object s, which is assigned a valid, free port in the range (0,127). Next, the \texttt{state} member is set to \texttt{SYN\_SENT} and a \texttt{SYN} packet is sent out on the connection. 

At this point, the socket blocks its handler thread until it receives a SYN/ACK interrupt from the network layer. Alternatively, a timeout from the alarm clock can break the code (how?). Once the \texttt{SYN/ACK} has arrived, \texttt{s.state} is set to \texttt{ESTABLISHED} and interrupts are re-enabled. At this point, the connection has been successfully opened and the function returns the integer value of sockets associated file descriptor.






\noindent Pseudocode:

\begin{lstlisting}
int connect(host, port){
	disable interrupts
	create a new socket s and assign it to a free port in (0,127)
	s.state = SYN_SENT
	send SYN packet
	block until SYN/ACK recv'd // timeout breaks this
	s.state = ESTABLISHED
	enable interrupts
	return s.fileDescriptor
}
\end{lstlisting}

\subsection{accept()}

Pseudocode:

\begin{lstlisting}
int acccept(port){
	disable interrupts
	if there are connections waiting on port
		create a new socket s, assign it that port
	else return -1
	s.state = ESTABLISHED
	send SYN/ACK
	enable interrupts
	return s.fileDescriptor
}
\end{lstlisting}

\subsection{write()}

\begin{lstlisting}
int write(fileDescriptor, buffer, count){
	...
	<netcode>
	...
}
\end{lstlisting}

\subsection{read()}

\begin{lstlisting}
int read(fileDescriptor, buffer, count){
	...
	// for a socket
	if (s.isOpen){
		read count bytes
		return bytes successfully read
	} else {
		if (socket isn't empty){
			read count bytes
			if (socket is empty)
				delete socket
			return bytes successfully read	
		}	
	}
}


\end{lstlisting}

\section{Threads}



\subsection{Send thread}

\subsection{Receive thread}
\subsection{Timeout thread}
This thread works like waitUntil, where it loops through the existing sockets and checks for any that have lived past their timeout value. If they have, it closes that socket.

\section{Test cases}
\subsection{connect()}
\begin{itemize}
	\item Attempt to open a connection to a node that doesn't exist
	\subitem Check that connect() blocks
	\item Open a connection to an existing node
	\subitem Check that connect() returns
	\item Close an already-open connection
	\subitem Verify that socket is closed on both sides
	\item Open multiple connections to the same receiving port
	\subitem Check that they all send/receive data
	\item Open a connection, close it and re-open it
\end{itemize}
\subsection{accept()}
\begin{itemize}
	\item Accept a waiting connection
	\item Accept multiple waiting connections on the same port
	\item Accept multiple waiting connections to different ports
	\item Return from accept() on a port that doesn't have a connection waiting
\end{itemize}
\subsection{close()}
\begin{itemize}
	\item Close a connection that doesn't exist
	\item Close a connection that exists
	\subitem Check that it's actually closed
	\item Close a connection as the sender and as the receiver
	\subitem Check 
	\item Close a connection twice in a row
	\subitem Check that errors don't occur
	\item Close a connection with a lot of data waiting
	\subitem Check that sender 
\end{itemize}
\subsection{read()}
\begin{itemize}
	\item Read from an open socket
	\subitem Check that it doesn't block
	\item Read from a closed socket with data remaining
	\subitem Check that it doesn't block
	\subitem Check that data is returned
	\subitem Return value?
	\item Read from an empty socket
	\subitem Check that it returns 0 w/o blocking
\end{itemize}
\subsection{write()}
\begin{itemize}
	\item Write to an open socket
	\item Write to a closed socket
	\subitem Check that it returns -1 immediately
\end{itemize}
\subsection{Connection}
\begin{itemize}
	\item Write to a connection and read from that connection on the receiving node
	\subitem Check that output matches input
	\subitem Check that window size never exceeds 16 packets (how?)
	\item Write to both sides of a connection simultaneously
	\item Read from both sides of a connection simultaneously
	\item Write/read to/from a connection with 10\% loss rate
	\subitem Check that output matches input
	\item Write a large amount of data into an open connection and read it on the receiving node
	\subitem Check that output matches input
\end{itemize}
\subsection{Chat client/server}
\begin{itemize}
	\item Broadcast a message to all clients
	\subitem Check that it works for small numbers and large numbers
	\subitem Check that output matches input for every client
	\subitem Check that sending a message doesn't interleave with receiving a message
	\item Connect a client, then drop the client
	\item Connect a client, drop the client, then reconnect that same client
	\item Connect multiple clients
	\item Drop multiple clients
	\item Reconnect multiple clients
	\item Broadcast multiple messages
	\subitem Check that the order of the messages is preserved for a given sender
	\item Quit the client
	\subitem Check that client exists gracefully (how?) after getting a single '.'
	\item Quit the server
	\subitem Check that the server exists upon receiving anything on stdin
	\subitem Check that all clients get a message about server closing
	
\end{itemize}
\end{document}
